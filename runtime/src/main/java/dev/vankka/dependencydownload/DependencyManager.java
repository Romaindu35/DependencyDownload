package dev.vankka.dependencydownload;

import dev.vankka.dependencydownload.classpath.ClasspathAppender;
import dev.vankka.dependencydownload.dependency.Dependency;
import dev.vankka.dependencydownload.dependency.SnapshotDependency;
import dev.vankka.dependencydownload.dependency.StandardDependency;
import dev.vankka.dependencydownload.repository.Repository;
import dev.vankka.dependencydownload.util.ExceptionalConsumer;
import dev.vankka.dependencydownload.util.HashUtil;
import me.lucko.jarrelocator.JarRelocator;
import me.lucko.jarrelocator.Relocation;

import javax.net.ssl.HttpsURLConnection;
import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CopyOnWriteArraySet;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

/**
 * The main class responsible for downloading, optionally relocating and loading in dependencies.
 */
public class DependencyManager {

    private static final String RELOCATED_FILE_PREFIX = "relocated_";

    private final Path cacheDirectory;

    private final List<Dependency> dependencies = new CopyOnWriteArrayList<>();
    private final Set<Relocation> relocations = new CopyOnWriteArraySet<>();
    private final AtomicInteger step = new AtomicInteger(0);

    /**
     * Creates a {@link DependencyManager}.
     * @param cacheDirectory the directory used for downloaded and relocated dependencies.
     */
    public DependencyManager(Path cacheDirectory) {
        this.cacheDirectory = cacheDirectory;
    }

    /**
     * Adds a dependency to this {@link DependencyManager}.
     * @param dependency the dependency
     */
    public void addDependency(Dependency dependency) {
        this.dependencies.add(dependency);
    }

    /**
     * Gets the dependencies in this {@link DependencyManager}.
     * @return a unmodifiable list of dependencies
     */
    public List<Dependency> getDependencies() {
        return Collections.unmodifiableList(dependencies);
    }

    /**
     * Adds a relocation to this {@link DependencyManager}.
     * @param relocation the relocation
     */
    public void addRelocation(Relocation relocation) {
        this.relocations.add(relocation);
    }

    /**
     * Gets the relocations in this {@link DependencyManager}.
     * @return a unmodifiable set of relocations
     */
    public Set<Relocation> getRelocations() {
        return Collections.unmodifiableSet(relocations);
    }

    /**
     * Loads dependencies and relocations from the resource generated by the gradle plugin.
     *
     * @param resourceURL the url to the resource
     * @throws IOException if the resource cannot be read
     */
    public void loadFromResource(URL resourceURL) throws IOException {
        if (resourceURL == null) {
            throw new NullPointerException("resourceURL");
        }

        List<String> lines;
        try (InputStream inputStream = resourceURL.openStream()) {
            lines = new BufferedReader(new InputStreamReader(inputStream))
                    .lines()
                    .collect(Collectors.toList());
        }

        loadFromResource(lines);
    }

    /**
     * Loads dependencies and relocations from the resource generated by the gradle plugin.
     *
     * @param fileContents the contents of the file generated by the gradle plugin as a {@link String}
     */
    public void loadFromResource(String fileContents) {
        if (fileContents == null) {
            throw new NullPointerException("fileContents");
        }
        loadFromResource(Arrays.asList(fileContents.split("\n")));
    }

    /**
     * Loads dependencies and relocations from the resource generated by the gradle plugin.
     *
     * @param fileLines all the lines from the file generated by the gradle plugin
     */
    @SuppressWarnings("ConstantConditions")
    public void loadFromResource(List<String> fileLines) {
        if (fileLines == null) {
            throw new NullPointerException("fileLines");
        }

        String hashingAlgorithm = null;

        int relocationStep = -1;
        String pattern = null;
        String replacement = null;
        List<String> include = null;
        for (String line : fileLines) {
            line = line.trim();
            if (line.isEmpty()) {
                continue;
            }

            if (line.startsWith("===ALGORITHM")) {
                String[] algorithmParts = line.split(" ");
                if (algorithmParts.length != 2) {
                    throw new IllegalArgumentException("Resource format is invalid: hashing algorithm: " + line);
                }
                hashingAlgorithm = algorithmParts[1];
                continue;
            } else if (hashingAlgorithm == null) {
                throw new IllegalArgumentException("Resource format is invalid: no hashing algorithm");
            } else if (line.startsWith("===RELOCATIONS") && relocationStep == -1) {
                relocationStep = 0;
                continue;
            } else if (relocationStep != -1) {
                switch (relocationStep) {
                    case 0:
                        pattern = line;
                        break;
                    case 1:
                        replacement = line;
                        break;
                    case 2:
                    case 3:
                        if (!line.startsWith("[") || !line.endsWith("]")) {
                            throw new IllegalArgumentException("Resource format is invalid: expecting a includes/excludes: " + line);
                        }
                        line = line.substring(1, line.length() - 1);

                        List<String> values;
                        if (!line.trim().isEmpty()) {
                            values = Arrays.asList(line.split(","));
                        } else {
                            values = Collections.emptyList();
                        }

                        if (relocationStep == 2) {
                            include = values;
                        } else {
                            relocations.add(new Relocation(pattern, replacement, include, values));
                            include = null;
                            relocationStep = 0;
                            continue;
                        }
                }

                relocationStep++;
                continue;
            }

            String[] parts = line.split(" ");
            if (parts.length != 2) {
                throw new IllegalArgumentException("Resource format is invalid: invalid dependency: " + line);
            }
            String maven = parts[0];
            String hash = parts[1];

            String[] mavenParts = maven.split(":");
            int partCount = mavenParts.length;
            if (partCount < 3 || partCount > 4) {
                throw new IllegalArgumentException("Resource format is invalid: invalid dependency GAV: " + maven + " (" + partCount + ")");
            }

            Dependency dependency;
            if (partCount == 3) {
                dependency = new StandardDependency(
                        mavenParts[0],
                        mavenParts[1],
                        mavenParts[2],
                        hash,
                        hashingAlgorithm
                );
            } else {
                dependency = new SnapshotDependency(
                        mavenParts[0],
                        mavenParts[1],
                        mavenParts[2],
                        mavenParts[3],
                        hash,
                        hashingAlgorithm
                );
            }

            dependencies.add(dependency);
        }
        if (relocationStep > 1) { // has pattern & replacement w/o include and/or exclude
            relocations.add(new Relocation(pattern, replacement, include, null));
        }
    }

    /**
     * Download all the dependencies in this {@link DependencyManager}.
     *
     * @param executor the executor that will run the downloads
     * @param repositories a ordered list of repositories that will be tried one-by-one
     * @return a future that will complete exceptionally if a single dependency fails to download from all repositories,
     * otherwise completes when all dependencies are downloaded
     * @throws IllegalStateException if dependencies have already been queued for download once
     */
    public CompletableFuture<Void> downloadAll(Executor executor, List<Repository> repositories) {
        return CompletableFuture.allOf(download(executor, repositories));
    }

    /**
     * Download all the dependencies in this {@link DependencyManager}.
     *
     * @param executor the executor that will run the downloads
     * @param repositories a ordered list of repositories that will be tried one-by-one
     * @return a array containing a {@link CompletableFuture} for each dependency
     * @throws IllegalStateException if dependencies have already been queued for download once
     */
    public CompletableFuture<Void>[] download(Executor executor, List<Repository> repositories) {
        if (!step.compareAndSet(0, 1)) {
            throw new IllegalStateException("Download has already been executed");
        }
        return forEachDependency(executor, dependency -> downloadDependency(dependency, repositories),
                (dependency, cause) -> new RuntimeException("Failed to download dependency " + dependency.getMavenArtifact(), cause));
    }

    /**
     * Relocates all the dependencies with the relocations in this {@link DependencyManager}. This step is not required.
     *
     * @param executor the executor that will run the relocations
     * @return a future that will complete exceptionally if any of the dependencies fail to
     * relocate otherwise completes when all dependencies are relocated
     * @throws IllegalStateException if dependencies have already been queued for relocation once
     */
    public CompletableFuture<Void> relocateAll(Executor executor) {
        return CompletableFuture.allOf(relocate(executor));
    }

    /**
     * Relocates all the dependencies with the relocations in this {@link DependencyManager}. This step is not required.
     *
     * @param executor the executor that will run the relocations
     * @return a array containing a {@link CompletableFuture} for each dependency
     * @throws IllegalStateException if dependencies have already been queued for relocation once
     */
    public CompletableFuture<Void>[] relocate(Executor executor) {
        int currentStep = step.get();
        if (currentStep == 0) {
            throw new IllegalArgumentException("Download hasn't been executed");
        } else if (currentStep != 1) {
            throw new IllegalArgumentException("Relocate has already been executed");
        }
        step.set(2);
        return forEachDependency(executor, this::relocateDependency,
                (dependency, cause) -> new RuntimeException("Failed to relocate dependency " + dependency.getMavenArtifact(), cause));
    }

    /**
     * Loads all the (potentially relocated) dependencies with provided {@link ClasspathAppender}.
     *
     * @param executor the executor that will load the dependencies
     * @param classpathAppender the classpath appender
     * @return a future that will complete exceptionally if any of the dependencies fail to
     * be appended by the provided {@link ClasspathAppender} otherwise completes when all dependencies are relocated
     * @throws IllegalStateException if dependencies have already been queued for load once
     */
    public CompletableFuture<Void> loadAll(Executor executor, ClasspathAppender classpathAppender) {
        return CompletableFuture.allOf(load(executor, classpathAppender));
    }

    /**
     * Loads all the (potentially relocated) dependencies with provided {@link ClasspathAppender}.
     *
     * @param executor the executor that will load the dependencies
     * @param classpathAppender the classpath appender
     * @return a array containing a {@link CompletableFuture} for each dependency
     * @throws IllegalStateException if dependencies have already been queued for load once
     */
    public CompletableFuture<Void>[] load(Executor executor, ClasspathAppender classpathAppender) {
        int currentStep = step.get();
        if (currentStep == 0) {
            throw new IllegalArgumentException("Download hasn't been executed");
        }
        step.set(3);

        return forEachDependency(executor, dependency -> loadDependency(dependency, classpathAppender, currentStep == 2),
                (dependency, cause) -> new RuntimeException("Failed to load dependency " + dependency.getMavenArtifact(), cause));
    }

    @SuppressWarnings("unchecked")
    private CompletableFuture<Void>[] forEachDependency(Executor executor, ExceptionalConsumer<Dependency> runnable,
                                                        BiFunction<Dependency, Throwable, Throwable> dependencyException) {
        int size = dependencies.size();
        CompletableFuture<Void>[] futures = new CompletableFuture[size];

        for (int index = 0; index < size; index++) {
            Dependency dependency = dependencies.get(index);

            CompletableFuture<Void> future = new CompletableFuture<>();
            Runnable run = () -> {
                try {
                    runnable.run(dependency);
                    future.complete(null);
                } catch (Throwable t) {
                    future.completeExceptionally(
                            dependencyException.apply(dependency, t));
                }
            };

            if (executor != null) {
                executor.execute(run);
            } else {
                run.run();
            }

            futures[index] = future;
            if (future.isCompletedExceptionally()) {
                // don't need to bother with the rest if one fails
                break;
            }
        }

        return futures;
    }

    private void downloadDependency(Dependency dependency, List<Repository> repositories) throws IOException, NoSuchAlgorithmException {
        if (!cacheDirectory.toFile().exists()) {
            Files.createDirectories(cacheDirectory);
        }

        String fileName = dependency.getFileName();
        File dependencyFile = new File(cacheDirectory.toFile(), fileName);
        if (dependencyFile.exists()) {
            String fileHash = HashUtil.getFileHash(dependencyFile, dependency.getHashingAlgorithm());
            if (fileHash.equals(dependency.getHash())) {
                // This dependency is already downloaded & the hash matches
                return;
            } else {
                Files.delete(dependencyFile.toPath());
            }
        }
        Files.createFile(dependencyFile.toPath());

        RuntimeException failure = new RuntimeException("All provided repositories failed to download dependency");
        for (Repository repository : repositories) {
            try {
                MessageDigest digest = MessageDigest.getInstance(dependency.getHashingAlgorithm());
                downloadFromRepository(dependency, repository, dependencyFile, digest);

                String hash = HashUtil.getHash(digest);
                String dependencyHash = dependency.getHash();
                if (!hash.equals(dependencyHash)) {
                    throw new RuntimeException("Failed to verify file hash: " + hash + " should've been: " + dependencyHash);
                }

                // Success
                return;
            } catch (Throwable e) {
                Files.deleteIfExists(dependencyFile.toPath());
                failure.addSuppressed(e);
            }
        }
        throw failure;
    }

    private void downloadFromRepository(Dependency dependency, Repository repository, File dependencyFile, MessageDigest digest) throws Throwable {
        HttpsURLConnection connection = repository.openConnection(dependency);

        byte[] buffer = new byte[4096];
        try (BufferedInputStream inputStream = new BufferedInputStream(connection.getInputStream())) {
            try (BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(dependencyFile))) {
                int total;
                while ((total = inputStream.read(buffer)) != -1) {
                    outputStream.write(buffer, 0, total);
                    digest.update(buffer, 0, total);
                }
            }
        }
    }

    private void relocateDependency(Dependency dependency) throws IOException {

        String fileName = dependency.getFileName();
        File dependencyFile = new File(cacheDirectory.toFile(), fileName);
        File relocatedFile = new File(cacheDirectory.toFile(), RELOCATED_FILE_PREFIX + fileName);

        JarRelocator jarRelocator = new JarRelocator(dependencyFile, relocatedFile, relocations);
        jarRelocator.run();
    }

    private void loadDependency(Dependency dependency, ClasspathAppender classpathAppender, boolean relocated) throws MalformedURLException {
        String fileName = dependency.getFileName();
        File relocatedFile = new File(cacheDirectory.toFile(), (relocated ? RELOCATED_FILE_PREFIX : "") + fileName);

        classpathAppender.appendFileToClasspath(relocatedFile.toPath());
    }
}
